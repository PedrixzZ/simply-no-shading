buildscript {
	repositories {
		gradlePluginPortal()
	}

	dependencies {
		classpath 'gradle.plugin.com.matthewprenger:CurseGradle:1.+'
		classpath 'com.modrinth.minotaur:Minotaur:2.+'
		classpath 'org.ajoberstar.grgit:grgit-gradle:4.+'
		classpath 'org.kohsuke:github-api:1.+'
	}
}

apply plugin: com.matthewprenger.cursegradle.CurseGradlePlugin
apply plugin: com.modrinth.minotaur.Minotaur
apply plugin: org.ajoberstar.grgit.gradle.GrgitPlugin

import com.modrinth.minotaur.dependencies.ModDependency

import org.kohsuke.github.GHReleaseBuilder
import org.kohsuke.github.GitHub

final def releaseMetadata = [
	dependencies: [
		'BedrockIfy':              [ type: 'optional', modrinthId: 'ox3rDp1B', curseforgeName: 'bedrockify'              ],
		'Enhanced Block Entities': [ type: 'optional', modrinthId: 'OVuFYfre', curseforgeName: 'enhanced-block-entities' ],
		'Fabric API':              [ type: 'required', modrinthId: 'P7dR8mSH', curseforgeName: 'fabric-api'              ],
		'Mod Menu':                [ type: 'optional', modrinthId: 'mOgUt4GM', curseforgeName: 'modmenu'                 ],
		'Sodium':                  [ type: 'optional', modrinthId: 'AANobbMI', curseforgeName: 'sodium'                  ]
	],
	gameVersion: project.gameVersion,
	gameVersionAlt: project.findProperty('gameVersionAlt') ?: project.gameVersion,
	implementationVersion: project.modVersion,
	loader: project.loader,
	version: project.version
].tap {
	changelog = "**View the changelog at:** https://github.com/${System.env.GITHUB_REPOSITORY}/wiki/Changelog#${implementationVersion.replace '.', ''}"
	loaderName = loader.capitalize()

	def baseVersion
	def qualifier
	def qualifierParts

	implementationVersion.split '-', 2 with { it as List } tap {
		baseVersion = it[0]
		qualifier = it[1] ?: ''
	}

	qualifierParts = qualifier ? qualifier.split(/\./, 2) : ['', '-1']

	if (qualifierParts.size() != 2)
		throw new RuntimeException("Non-empty qualifiers are formatted <rc|pre|snapshot>.<int> but was $qualifier")

	def qualifierName

	switch (qualifierParts[0]) {
	case '':    qualifierName = '';                  releaseChannel = 'release'; break
	case 'rc':  qualifierName = 'Release Candidate'; releaseChannel = 'beta';    break
	case 'pre': qualifierName = 'Pre-Release';       releaseChannel = 'beta';    break
	default:    qualifierName = 'Snapshot';          releaseChannel = 'alpha';   break
	}

	versionName = "$baseVersion${qualifierName ? " $qualifierName ${qualifierParts[1]}" : ''} for Minecraft $gameVersion"
}

curseforge {
	apiKey = System.env.'CURSEFORGE_API_KEY' ?: ''

	project {
		id = '550997'

		changelogType = 'markdown'
		changelog = releaseMetadata.changelog
		relations {
			for (dependency in releaseMetadata.dependencies.values()) {
				final def name = dependency.curseforgeName

				switch (dependency.type) {
				case 'embedded':     embeddedDependency name;     break
				case 'incompatible': incompatibleDependency name; break
				case 'optional':     optionalDependency name;     break
				case 'required':     requiredDependency name;     break
				}
			}
		}

		releaseType = releaseMetadata.releaseChannel
		addGameVersion releaseMetadata.gameVersionAlt
		addGameVersion "Java $javaVersion"
		addGameVersion releaseMetadata.loaderName

		mainArtifact remapJar, {
			displayName = releaseMetadata.versionName
		}

		afterEvaluate {
			uploadTask.dependsOn 'remapJar'
		}
	}

	options {
		forgeGradleIntegration = false
	}
}

modrinth {
	token = System.env.'MODRINTH_TOKEN'
	projectId = '9gx5Xvc5'

	versionName = releaseMetadata.versionName
	versionType = releaseMetadata.releaseChannel
	versionNumber = releaseMetadata.version
	loaders = [ releaseMetadata.loader ]
	gameVersions = [ releaseMetadata.gameVersion ]

	changelog = releaseMetadata.changelog
	dependencies = releaseMetadata.dependencies.values() collect { new ModDependency(it.modrinthId, it.type) }

	uploadFile = remapJar
}

tasks.register 'github', {
	dependsOn 'remapJar'

	onlyIf {
		final def tokenExists = System.env.GITHUB_TOKEN
		final def nonAlpha = releaseMetadata.releaseChannel in [ 'release', 'beta' ]

		return tokenExists && nonAlpha
	}

	doLast {
		final def github = GitHub.connectUsingOAuth(System.env.GITHUB_TOKEN as String)
		final def repository = github.getRepository(System.env.GITHUB_REPOSITORY)
		final def releaseBuilder = new GHReleaseBuilder(repository, version as String)

		releaseBuilder.name(releaseMetadata.versionName)
		releaseBuilder.body(releaseMetadata.changelog)
		releaseBuilder.commitish(getBranch())
		releaseBuilder.prerelease(releaseMetadata.releaseChannel != 'release')

		final def release = releaseBuilder.create()

		release.uploadAsset(remapJar.archiveFile.get().asFile, 'application/java-archive');
	}
}

def getBranch() {
	if (System.env.GITHUB_REF)
		return System.env.GITHUB_REF
	if (grgit == null)
		return 'unknown'

	final def currentBranch = grgit.branch.current()
	final def name = currentBranch.name

	return name.substring(branch.lastIndexOf('/') + 1)
}
